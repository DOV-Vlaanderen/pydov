import warnings

from dataclasses import dataclass

from pydov.search.abstract import AbstractCommon
from pydov.util.dovutil import (
    build_dov_sparql_request, get_remote_url, get_remote_request)
from pydov.util.errors import CodelistFetchWarning, RemoteFetchError
from pydov.util.hooks import HookRunner

from owslib.etree import etree


class MemoryCache(object):
    """Simple cache to save objects in memory.

    Used here to avoid downloading the same codelists twice during the
    runtime of a pydov session.

    """
    cache = {}

    @staticmethod
    def get(key, fn, *args, **kwargs):
        """Retrieve an object from the in-memory cache or generate it if not
        present.

        This method checks if the provided `key` is present in the cache. If
        the key is not found, it calls the provided `fn` function with the
        given `*args` and `**kwargs`, and stores the result in the cache under
        the `key`.

        If the key is found in the cache, the method simply returns the cached
        object.

        Returns
        -------
        object
            The object retrieved from the cache or generated by the `fn`
            function.
        """
        if key not in MemoryCache.cache:
            MemoryCache.cache[key] = fn(*args, **kwargs)

        return MemoryCache.cache.get(key)

    @staticmethod
    def clear():
        """Clear the memory cache.

        This method clears the memory cache, removing all cached data.
        """
        MemoryCache.cache.clear()


@dataclass
class CodeListItem:
    """Class to represent an item in a codelist.
    """
    code: str
    label: str


class AbstractCodeList(object):
    """Abstract base class for codelists."""
    def __init__(self):
        """Initialisation."""
        self.items = []

    def get_values(self):
        """Get a dictionary of values of the codelist.

        Returns
        -------
        dict or None
            A dictionary with a mapping of codes to labels of this codelist.
            If the codelist is empty, returns None.
        """
        if len(self.items) > 0:
            return dict((item.code, item.label) for item in self.items)


class AbstractResolvableCodeList(AbstractCommon, AbstractCodeList):
    """Abstract base class for resolvable codelists.

    A resolvable codelist will load its values from another datasource.

    """
    def __init__(self, datatype):
        """Initialisation.

        Parameters
        ----------
        datatype : str
            The datatype of the codes of the codelist. One of
            `string`, `float`, `integer`, `date`, `datetime`, `boolean`.
        """
        super().__init__()
        self.datatype = datatype

    def get_id(self):
        """Get a unique id for this codelist. Needs to be unique among all
        codelists and will be used for caching.

        Raises
        ------
        NotImplementedError
            This is an abstract method that should be implemented in a
            subclass.
        """
        raise NotImplementedError

    def get_remote_codelist(self):
        """Fetch the remote codelist.

        Returns
        -------
        codelist : any
            Codelist in a format that can be parsed by the
            parse_codelist_items method.

        Raises
        ------
        NotImplementedError
            This is an abstract method that should be implemented in a
            subclass.
        """
        raise NotImplementedError

    def parse_codelist_items(self, codelist):
        """Parse the codelist items from the fetched codelist.

        Parameters
        ----------
        codelist : any
            Codelist to parse.

        Yields
        ------
        item : CodelistItem
            A CodelistItem for each item in the codelist.

        Raises
        ------
        NotImplementedError
            This is an abstract method that should be implemented in a
            subclass.
        """
        raise NotImplementedError

    def resolve(self):
        """Resolve the remote codelist values."""
        codelist = self.get_remote_codelist()
        self.items = list(self.parse_codelist_items(codelist))

    def get_values(self):
        """Get a dictionary of values of the codelist.

        Returns
        -------
        dict or None
            A dictionary with a mapping of codes to labels of this codelist.
            If the codelist is empty, returns None.
        """
        self.resolve()
        return super().get_values()


class OsloCodeList(AbstractResolvableCodeList):
    """Class representing a codelist in the OSLO linked data format."""

    def __init__(self, conceptscheme, datatype):
        """Initialisation.

        Parameters
        ----------
        conceptscheme : str
            OSLO conceptscheme which will be used for this codelist
        datatype : str
            The datatype of the codes of the codelist. One of
            `string`, `float`, `integer`, `date`, `datetime`, `boolean`.
        """
        super().__init__(datatype)
        self.conceptscheme = conceptscheme
        self._codelist = None

    def get_id(self):
        return f'{self.conceptscheme}.xml'

    def build_sparql_query(self):
        """Build the SPARQL query to fetch the codelist from DOV.

        Returns
        -------
        query : str
            The SPARQL query to fetch the codelist.

        """
        return """
            PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
            PREFIX conceptscheme:
            <https://data.bodemenondergrond.vlaanderen.be/id/conceptscheme/>

            SELECT ?code ?label ?definition
            WHERE {{
            ?s skos:inScheme conceptscheme:{} .
            ?s skos:notation ?code .
            ?s skos:prefLabel ?label .
            ?s skos:note ?definition .
            }}
        """.format(self.conceptscheme)

    def get_remote_codelist(self):
        request = build_dov_sparql_request(self.build_sparql_query())

        response = HookRunner.execute_inject_meta_response(request.url)

        if response is None:
            try:
                response = MemoryCache.get(
                    self.get_id(), get_remote_request, request)
            except RemoteFetchError:
                warnings.warn(
                    "Failed to fetch remote sparql data, metadata will "
                    "be incomplete.", CodelistFetchWarning)
                response = None

        HookRunner.execute_meta_received(request.url, response)

        return response

    def parse_codelist_items(self, codelist):
        if codelist is not None:
            tree = etree.fromstring(codelist)

            tree_solutions = tree.findall(
                './/{http://www.w3.org/2005/sparql-results#}solution'
            )

            for s in tree_solutions:
                code = s.find(
                    './/{http://www.w3.org/2005/sparql-results#}binding['
                    '{http://www.w3.org/2005/sparql-results#}variable="code"]'
                    '/{http://www.w3.org/2005/sparql-results#}value').text
                label = s.find(
                    './/{http://www.w3.org/2005/sparql-results#}binding['
                    '{http://www.w3.org/2005/sparql-results#}variable="label"]'
                    '/{http://www.w3.org/2005/sparql-results#}value').text
                yield CodeListItem(code, label)


class XsdType(AbstractResolvableCodeList):
    """Class representing a codelist in the XSD format."""

    def __init__(self, xsd_schema, typename, datatype):
        """Initialise a XSD type reference.

        Parameters
        ----------
        xsd_schema : str
            URL of XSD schema record containing the specified typename.
        typename : str
            Name of the type.
        datatype : str
            The datatype of the codes of the codelist. One of
            `string`, `float`, `integer`, `date`, `datetime`, `boolean`.

        """
        super().__init__(datatype)

        self.source_url = xsd_schema
        self.typename = typename
        self._schema = None

    def get_id(self):
        return self.source_url.split('/')[-1]

    def get_remote_codelist(self):
        response = HookRunner.execute_inject_meta_response(self.source_url)

        if response is None:
            try:
                response = MemoryCache.get(
                    self.get_id(), get_remote_url, self.source_url)
            except RemoteFetchError:
                warnings.warn(
                    "Failed to fetch remote codelist, metadata will "
                    "be incomplete.", CodelistFetchWarning)
                response = None

        HookRunner.execute_meta_received(self.source_url, response)

        return response

    def parse_codelist_items(self, codelist):
        if codelist is not None:
            tree = etree.fromstring(codelist)

            tree_values = tree.findall(
                './/{{http://www.w3.org/2001/XMLSchema}}simpleType['
                '@name="{}"]/'
                '{{http://www.w3.org/2001/XMLSchema}}restriction/'
                '{{http://www.w3.org/2001/XMLSchema}}enumeration'.format(
                    self.typename))

            for e in tree_values:
                code = self._typeconvert(
                    e.get('value'), self.datatype)
                label = e.findtext(
                    './{http://www.w3.org/2001/XMLSchema}annotation/{'
                    'http://www.w3.org/2001/XMLSchema}documentation')
                yield CodeListItem(code, label)
